#!/usr/bin/python

import pygame
import sys
import math

from random import randrange, random, seed
from colorsys import hsv_to_rgb
import private.Main

NCRATONS=40
MARGIN=12.

SCALE=10
MAX_H=256
MAX_X=(1<<SCALE)+1
PRESEED=1<<8 # 256px between control points
CRAGGINESS=1.0

VPO_X=300
VPO_Y=40
VP=384

CX=VPO_X + VP/2.0 * (1.0 - 1.0/math.sqrt(3))
CY=VPO_Y + VP/2.0
CR=160

cratons = []

seed(private.Main.LANDSCAPE_MAIN_SEED)

class Craton(object):
    def __init__(self, i,
                 x = None,
                 y = None,
                 height = None):
        if x == None: x = randrange(VPO_X-VP/2, VPO_X+3*VP/2)
        if y == None: y = randrange(VPO_Y, VPO_Y+VP)
        if height == None: height = randrange(-MAX_H, MAX_H+1)
        
        self.i = i
        self.x = x
        self.y = y
        self.height = height

        craggy = random()
        self.craggy = 3.0*craggy + 1.0

#        self.colour = hsv_to_rgb(i/float(NCRATONS), 0.1, 1.0)
        self.colour = hsv_to_rgb(craggy * 2.0 / 3.0, 0.1, 1.0)
        self.colour = [ j*256 for j in self.colour ]

    def d2(self, x, y):
        dx = x - self.x
        dy = y - self.y
        return dx*dx + dx*dy + dy*dy

class Loc(object):
    def __init__(self, x, y, c1, d1):
        self.x = x
        self.y = y
        self.nearest = c1
#        self.nearest_d = math.sqrt(d1)
        self.height = None # Initial height

def to_scr(x, y):
    return ((x-VPO_X)*2 + y, (y-VPO_Y)*2)
            
def plot(f, prefix, gamma, min_level, max_level, step_level):
    # Work out the dynamic range of the landscape
    max_v = -1e8
    for x in range(0, MAX_X):
        for y in range(0, MAX_X-x):
            v = f(x, y)
            if v != None:
                max_v = max(max_v, abs(v))

    print "Value range:", -max_v, "to", max_v

    # Draw the output
    pygame.init()
    screen = pygame.display.set_mode((VP*2, VP*2))
    screen.fill((0,0,0))

    dcount = 0
    for depth in range(min_level, max_level, step_level):
        dcount += 1
        for x in range(VPO_X-VP/2, VPO_X+3*VP/2):
            for y in range(VPO_Y, VPO_Y+VP):
                if x+y >= MAX_X:
                    continue

                dx = x-CX
                dy = y-CY
#                r = math.sqrt(dx*dx + dx*dy + dy*dy)  # Circle (2-metric)
                r = max(abs(dx), abs(dy), abs(dx+dy)) # Hexagon (1-metric)

                v = f(x, y)
                if v == None:
                    col = (255, 0, 0)
                elif abs(r - CR) < 0.8:
                    col = (0, 255, 0)
                else:
                    if v < depth:
                        col = (0, 0, 255)
                    else:
                        c = float((v+max_v)/(max_v*2.0+1))
                        c = math.pow(c, gamma)
                        col = [int(c*loc[x][y].nearest.colour[i]) for i in (0, 1, 2)]
                        #col = [int(c * 256) for i in (0, 1, 2)]

                pygame.draw.rect(screen,
                                 col,
                                 pygame.Rect(to_scr(x, y), (2, 2)))

        for c in cratons:
            pygame.draw.circle(screen, (255, 0, 0), to_scr(c.x, c.y), 2)

        pygame.image.save(screen, "%s-%d-%03d.tga" % (prefix, dcount, depth))
        print "Saved %d" % depth

def calc_fnoise(fnoise):
    for sc in range(SCALE-1, -1, -1):
        stride = 1 << sc
        print sc, stride
        xbit = True
        for x in range(0, MAX_X, stride):
            xbit = not xbit
            ybit = True
            maxy = MAX_X - x
            for y in range(0, maxy, stride):
                ybit = not ybit
                if fnoise[x][y].height != None:
                    continue
                tot = 0.0
                count = 0.0
                if xbit:
                    if ybit:
                        if y - stride >= 0 and (y-stride) + (x+stride) <= MAX_X:
                            count += 2
                            tot += 2* fnoise[x+stride][y-stride].height
                        if x - stride >= 0 and (y+stride) + (x-stride) <= MAX_X:
                            count += 2
                            tot += 2* fnoise[x-stride][y+stride].height
                        if x - stride >= 0 and y - stride >= 0:
                            count += 1
                            tot += fnoise[x-stride][y-stride].height
                        if (y+stride) + (x+stride) <= MAX_X:
                            count += 1
                            tot += fnoise[x+stride][y+stride].height
                    else:
                        if x - stride >= 0:
                            count += 2
                            tot += 2* fnoise[x-stride][y].height
                        if y + (x+stride) <= MAX_X:
                            count += 2
                            tot += 2* fnoise[x+stride][y].height
                        if ( (y+2*stride) + (x-stride) <= MAX_X
                             and x - stride >= 0):
                            count += 1
                            tot += fnoise[x-stride][y+2*stride].height
                        if y - 2*stride >= 0:
                            count += 1
                            tot += fnoise[x+stride][y-2*stride].height
                else:
                    if ybit:
                        if y - stride >= 0:
                            count += 2
                            tot += 2* fnoise[x][y-stride].height
                        if y + stride <= maxy:
                            count += 2
                            tot += 2* fnoise[x][y+stride].height
                        if x - 2*stride >= 0:
                            count += 1
                            tot += fnoise[x-2*stride][y+stride].height
                        if ( (y-stride) + (x+2*stride) <= MAX_X
                            and y - stride >= 0):
                            count += 1
                            tot += fnoise[x+2*stride][y-stride].height
                    else:
                        print "xbit and ybit are both false: WTF?"
    
                if count == 0.0:
                    print "Count is zero: WTF?", stride, x, y, xbit, ybit, maxx, maxy
    
                fnoise[x][y].height = tot / count

                rrange = stride * CRAGGINESS * loc[x][y].nearest.craggy

                fnoise[x][y].height += randrange(-math.floor(rrange),
                                                 math.floor(rrange)+1)

def find_min(loc, x, y, min_h, min_pos):
    if x > 0 and y > 0 and x+y < MAX_X:
        if loc[x][y].height < min_h:
            return (loc[x][y].height, loc[x][y])
    return (min_h, min_pos)

def set_downhill(loc):
    for x in range(0, MAX_X):
        for y in range(0, MAX_X-x):
            min_h = loc[x][y].height
            min_pos = None
            (min_h, min_pos) = find_min(loc, x-1, y, min_h, min_pos)
            (min_h, min_pos) = find_min(loc, x+1, y, min_h, min_pos)
            (min_h, min_pos) = find_min(loc, x, y-1, min_h, min_pos)
            (min_h, min_pos) = find_min(loc, x, y+1, min_h, min_pos)
            (min_h, min_pos) = find_min(loc, x-1, y+1, min_h, min_pos)
            (min_h, min_pos) = find_min(loc, x+1, y-1, min_h, min_pos)
            loc[x][y].downhill = min_pos
            loc[x][y].water = 0

# Generate a set of cratons
for i in range(0, NCRATONS):
    cratons.append(Craton(i))

#cratons.append(Craton(0, -50, 0, 30))
#cratons.append(Craton(1, 50, 0, 50))
#cratons.append(Craton(2, 0, 75, 70))

# Compute for each point in the output space the nearest craton
loc = [ [ None for y in range(0, MAX_X-x) ] for x in range(0, MAX_X) ]
for x in range(0, MAX_X):
    for y in range(0, MAX_X-x): 
        d = 1e8
        cton = None
        for c in cratons:
            dist = c.d2(x, y)
            if dist < d:
                d = dist
                cton = c

        loc[x][y] = Loc(x, y, cton, d)

# Average out the cratons
#for c in cratons:
#    c.average()

# Set a bunch of seed points
for x in range(0, MAX_X, PRESEED):
    for y in range(0, MAX_X-x, PRESEED):
        if 0 <= y <= CY-CR/2:
            loc[x][y].height = 0
        else:
            loc[x][y].height = randrange(0, MAX_H)

# Compute the fractal noise function
calc_fnoise(loc)

# Work out which way is downhill
set_downhill(loc)

# Run downhill for each position until we can't go down any
# further. Keep track of the quantities
for x in range(0, MAX_X):
    for y in range(0, MAX_X-x):
        px = x
        py = y
        while loc[px][py].downhill != None:
            nx = loc[px][py].downhill.x
            ny = loc[px][py].downhill.y
            px = nx
            py = ny
            loc[px][py].water += 1

# Plot the landscape
plot(lambda x, y: loc[x][y].height, "level", 1.0, -32, 33, 16)
plot(lambda x, y: loc[x][y].water, "hydro", 1.0, 128, 129, 1)
