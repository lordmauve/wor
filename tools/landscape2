#!/usr/bin/python

import pygame
import sys
import math

from random import randrange, random, seed
from colorsys import hsv_to_rgb
import private.Main

NCRATONS=20
MARGIN=12.

SCALE=10
MAX_H=256
MAX_X=(1<<SCALE)+1
PRESEED=1<<6 # 64px between control points
CRAGGINESS=1.0

VPO_X=300
VPO_Y=40
VP=384

CX=VPO_X + VP/2.0 * (1.0 - 1.0/math.sqrt(3))
CY=VPO_Y + VP/2.0
CR=160

cratons = []
sinks = []

seed(private.Main.LANDSCAPE_MAIN_SEED)

class Craton(object):
    def __init__(self, i,
                 x = None,
                 y = None,
                 height = None):
        if x == None: x = randrange(VPO_X-VP/2, VPO_X+3*VP/2)
        if y == None: y = randrange(VPO_Y, VPO_Y+VP)
        if height == None: height = randrange(-MAX_H, MAX_H+1)
        
        self.i = i
        self.x = x
        self.y = y
        self.height = height

        craggy = random()
        self.craggy = 3.0*craggy + 1.0

#        self.colour = hsv_to_rgb(i/float(NCRATONS), 0.1, 1.0)
        self.colour = hsv_to_rgb(craggy * 2.0 / 3.0, 0.1, 1.0)
        self.colour = [ j*256 for j in self.colour ]

    def d2(self, x, y):
        dx = x - self.x
        dy = y - self.y
        return dx*dx + dx*dy + dy*dy

class Loc(object):
	def __init__(self, x, y, c1, d1):
		self.x = x
		self.y = y
		self.nearest = c1
		#self.nearest_d = math.sqrt(d1)
		self.height = None # Initial height

	def __str__(self):
		return "(" + str(self.x) + ", " + str(self.y) + ")@" + str(self.height) + "," + str(self.water)

def to_scr(x, y):
    return ((x-VPO_X)*2 + y, (y-VPO_Y)*2)
            
def plot(f, prefix, gamma, min_level, max_level, step_level, zero_origin=False):
    # Work out the dynamic range of the landscape
	max_v = -1e8
	min_v =  1e8
	for x in range(0, MAX_X):
		for y in range(0, MAX_X-x):
			v = f(x, y)
			if v != None:
				if zero_origin:
					max_v = max(max_v, v)
					min_v = min(min_v, v)
				else:
					max_v = max(max_v, abs(v))
					min_v = -max_v

	print "Value range:", min_v, "to", max_v

	# Draw the output
	pygame.init()
	screen = pygame.display.set_mode((VP*2, VP*2))
	screen.fill((0,0,0))

	dcount = 0
	for depth in range(min_level, max_level, step_level):
		dcount += 1
		for x in range(VPO_X-VP/2, VPO_X+3*VP/2):
			for y in range(VPO_Y, VPO_Y+VP):
				if x+y >= MAX_X:
					continue

				dx = x-CX
				dy = y-CY
                #r = math.sqrt(dx*dx + dx*dy + dy*dy)  # Circle (2-metric)
				r = max(abs(dx), abs(dy), abs(dx+dy)) # Hexagon (1-metric)

				v = f(x, y)
				if v == None:
					col = (255, 0, 0)
				elif abs(r - CR) < 0.8:
					col = (0, 255, 0)
				else:
					if v < depth:
						col = (0, 0, 255)
					else:
						# Normalise to range [0.0, 1.0)
						c = float(v-min_v)/float(max_v-min_v+1)
						c = math.pow(c, gamma)
						col = [int(c*loc[x][y].nearest.colour[i]) for i in (0, 1, 2)]
						#col = [int(c * 256) for i in (0, 1, 2)]

				pygame.draw.rect(screen,
								 col,
								 pygame.Rect(to_scr(x, y), (2, 2)))

		for c in cratons:
			pygame.draw.circle(screen, (255, 0, 0), to_scr(c.x, c.y), 2)

		pygame.image.save(screen, "%s-%d-%03d.tga" % (prefix, dcount, depth))
		print "Saved %d" % depth

def calc_fnoise(fnoise):
    for sc in range(SCALE-1, -1, -1):
        stride = 1 << sc
        print sc, stride
        xbit = True
        for x in range(0, MAX_X, stride):
            xbit = not xbit
            ybit = True
            maxy = MAX_X - x
            for y in range(0, maxy, stride):
                ybit = not ybit
                if fnoise[x][y].height != None:
                    continue
                tot = 0.0
                count = 0.0
                if xbit:
                    if ybit:
                        if y - stride >= 0 and (y-stride) + (x+stride) <= MAX_X:
                            count += 2
                            tot += 2* fnoise[x+stride][y-stride].height
                        if x - stride >= 0 and (y+stride) + (x-stride) <= MAX_X:
                            count += 2
                            tot += 2* fnoise[x-stride][y+stride].height
                        if x - stride >= 0 and y - stride >= 0:
                            count += 1
                            tot += fnoise[x-stride][y-stride].height
                        if (y+stride) + (x+stride) <= MAX_X:
                            count += 1
                            tot += fnoise[x+stride][y+stride].height
                    else:
                        if x - stride >= 0:
                            count += 2
                            tot += 2* fnoise[x-stride][y].height
                        if y + (x+stride) <= MAX_X:
                            count += 2
                            tot += 2* fnoise[x+stride][y].height
                        if ( (y+2*stride) + (x-stride) <= MAX_X
                             and x - stride >= 0):
                            count += 1
                            tot += fnoise[x-stride][y+2*stride].height
                        if y - 2*stride >= 0:
                            count += 1
                            tot += fnoise[x+stride][y-2*stride].height
                else:
                    if ybit:
                        if y - stride >= 0:
                            count += 2
                            tot += 2* fnoise[x][y-stride].height
                        if y + stride <= maxy:
                            count += 2
                            tot += 2* fnoise[x][y+stride].height
                        if x - 2*stride >= 0:
                            count += 1
                            tot += fnoise[x-2*stride][y+stride].height
                        if ( (y-stride) + (x+2*stride) <= MAX_X
                            and y - stride >= 0):
                            count += 1
                            tot += fnoise[x+2*stride][y-stride].height
                    else:
                        print "xbit and ybit are both false: WTF?"

                if count == 0.0:
                    print "Count is zero: WTF?", stride, x, y, xbit, ybit, maxx, maxy

                fnoise[x][y].height = tot / count

                rrange = stride * CRAGGINESS * loc[x][y].nearest.craggy

                fnoise[x][y].height += randrange(-math.floor(rrange),
                                                 math.floor(rrange)+1)

def find_min(loc, x, y, min_h, min_pos):
    if x > 0 and y > 0 and x+y < MAX_X:
        if loc[x][y].height < min_h:
            return (loc[x][y].height, loc[x][y])
    return (min_h, min_pos)

def set_downhill(loc):
	for x in range(0, MAX_X):
		for y in range(0, MAX_X-x):
			min_h = loc[x][y].height
			min_pos = None
			(min_h, min_pos) = find_min(loc, x-1, y, min_h, min_pos)
			(min_h, min_pos) = find_min(loc, x+1, y, min_h, min_pos)
			(min_h, min_pos) = find_min(loc, x, y-1, min_h, min_pos)
			(min_h, min_pos) = find_min(loc, x, y+1, min_h, min_pos)
			(min_h, min_pos) = find_min(loc, x-1, y+1, min_h, min_pos)
			(min_h, min_pos) = find_min(loc, x+1, y-1, min_h, min_pos)
			loc[x][y].downhill = min_pos
			if min_pos == None:
				sinks.append(loc[x][y])
			loc[x][y].water = 0

def run_downhill(x, y, amount):
	while loc[x][y].downhill != None:
		nx = loc[x][y].downhill.x
		ny = loc[x][y].downhill.y
		x = nx
		y = ny
		loc[x][y].water += amount

def test_add(collection, loc):
	if not hasattr(loc, 'lake'):
		collection.add(loc)

# Generate a set of cratons
print "Generating cratons"
for i in range(0, NCRATONS):
    cratons.append(Craton(i))

#cratons.append(Craton(0, -50, 0, 30))
#cratons.append(Craton(1, 50, 0, 50))
#cratons.append(Craton(2, 0, 75, 70))

# Compute for each point in the output space the nearest craton
print "Finding nearest craton"
loc = [ [ None for y in range(0, MAX_X-x) ] for x in range(0, MAX_X) ]
for x in range(0, MAX_X):
	if x % 10 == 0:
		sys.stdout.write(".")
		sys.stdout.flush()
	for y in range(0, MAX_X-x): 
		d = 1e8
		cton = None
		for c in cratons:
			dist = c.d2(x, y)
			if dist < d:
				d = dist
				cton = c

		loc[x][y] = Loc(x, y, cton, d)
print ""

# Set a bunch of seed points
print "Setting seeds"
for x in range(0, MAX_X, PRESEED):
    for y in range(0, MAX_X-x, PRESEED):
        if y <= CY-CR/3.0:
            # Bottom third is a touch lower than sea-level
            loc[x][y].height = -MAX_H/100.0
        elif CY-CR/3.0 <= y <= CY+CR/3.0:
            # Middle third is mountainous
            ypos = (y-CY) / CR * 3.0
            loc[x][y].height = MAX_H * math.cos(ypos*math.pi/2.0)
            rrange = int(math.ceil(MAX_H/10.0))
            loc[x][y].height += randrange(-rrange, rrange+1)
        else:
            # Top third is flattish lowlands
            loc[x][y].height = randrange(int(MAX_H/5.0), int(MAX_H/3.0))

# Compute the fractal noise function
print "Computing fractal"
calc_fnoise(loc)

# Work out which way is downhill
print "Finding terrain slopes"
set_downhill(loc)

# Hydrology: Run downhill for each position until we can't go down any
# further. Keep track of the quantities.
print "Hydro calculation"
for x in range(0, MAX_X):
	if x % 10 == 0:
		sys.stdout.write(".")
		sys.stdout.flush()
	for y in range(0, MAX_X-x):
		run_downhill(x, y, 1)
print ""

# More hydrology: work out where lakes should go.
# While we have lakes unexamined
print "Filling up lakes"
for sink in sinks:
	candidates = set()
	if sink.x > 0:
		test_add(candidates, loc[sink.x-1][sink.y])
		test_add(candidates, loc[sink.x-1][sink.y+1])
	if sink.y > 0:
		test_add(candidates, loc[sink.x][sink.y-1])
		test_add(candidates, loc[sink.x+1][sink.y-1])
	if sink.x + sink.y < MAX_X-1:
		test_add(candidates, loc[sink.x+1][sink.y])
		test_add(candidates, loc[sink.x][sink.y+1])
	sink.lake = sink

	print "Starting sink:", sink.x, sink.y

	while len(candidates) > 0:
		print candidates
		
		# Find the minimum one
		minloc = None
		for c in candidates:
			if minloc == None or minloc.height < c.height:
				minloc = c

		print "Min candidate =", minloc
		# Add minloc to the lake
		minloc.lake = sink
		# Increase lake height
		minloc.lake.height = minloc.height
		# Remove minloc from the list of candidates
		candidates.discard(minloc)

		# Add its borders to the candidates list
		sample = set()
		if minloc.x > 0:
			test_add(sample, loc[minloc.x-1][minloc.y])
			test_add(sample, loc[minloc.x-1][minloc.y+1])
		if minloc.y > 0:
			test_add(sample, loc[minloc.x][minloc.y-1])
			test_add(sample, loc[minloc.x+1][minloc.y-1])
		if minloc.x + minloc.y < MAX_X-1:
			test_add(sample, loc[minloc.x+1][minloc.y])
			test_add(sample, loc[minloc.x][minloc.y+1])

		# If any of the new candidates has a height lower than the
		# lake height, remove all candidates related to this lake, and
		# roll downhill with all the lake's input
		print "Want to update with", sample
		for l in sample:
			if l.height < minloc.lake.height:
				candidates = set()
				sample = set()
				run_downhill(l.x, l.y, minloc.lake.water)
				# FIXME: If we've hit a lake, go find the lake exit
				# and continue down.
				print "Downhill found: running out"
				break

		candidates |= sample

# Plot the landscape
#plot(lambda x, y: loc[x][y].height, "level", 1.0, -32, 33, 16)
# Plot the hydro layer
plot(lambda x, y: loc[x][y].water, "hydro", 0.7, -1, 0, 1, True)

plot(lambda x, y: hasattr(loc[x][y], 'lake'), "lakes", 0.0, -1, 0, 1, True)
