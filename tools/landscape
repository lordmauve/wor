#!/usr/bin/python

import pygame
import sys
import math

from random import randrange, random
from colorsys import hsv_to_rgb

NCRATONS=40
MARGIN=12.

MIN_X=-150
MIN_Y=-150
MIN_H=0
MAX_X=150
MAX_Y=150
MAX_H=500

MAX_D=20

MOUNTAIN_THRESHOLD = 40
MOUNTAIN_HALF = 50
SMOOTHNESS = 1
SEED_SCALE = 4

cratons = []

class Craton(object):
    def __init__(self, i,
                 x = None,
                 y = None,
                 height = None,
                 driftx = None,
                 drifty = None):
        if x == None: x = randrange(MIN_X, MAX_X+1)
        if y == None: y = randrange(MIN_Y, MAX_Y+1)
        if height == None: height = randrange(0, 150)
        
        self.i = i
        self.x = x
        self.y = y
        self.height = height
        self.cragginess = random()+1.0
        
        if driftx == None or drifty == None:
            r = randrange(0, MAX_D)+1
            t = math.radians(randrange(0, 360))
            self.driftx = r * math.cos(t)
            self.drifty = r * math.sin(t)
        else:
            self.driftx = driftx
            self.drifty = drifty
        self.colour = hsv_to_rgb(i/float(NCRATONS), 1.0, 1.0)
        self.colour = [ j*255 for j in self.colour ]
        self.neighbours = set()
        self.relations = set()

    def d2(self, x, y):
        dx = self.x - x
        dy = self.y - y
        return dx*dx + dy*dy

    def add_nbr(self, c):
        if c not in self.neighbours:
            self.neighbours.add(c)
            self.relations.add(CratonRelation(self, c))

    def average(self):
        tot = 2 * self.height
        for c in self.neighbours:
            tot += c.height
        self.height = tot / (len(self.neighbours) + 2)

    def mountains(self, x, y):
        tot = 0
        for rel in self.relations:
            tot += rel.mountains(x, y)

        return tot

class CratonRelation(object):
    def __init__(self, c1, c2):
        self.c1 = c1
        self.c2 = c2

        print "From", c1.i, "to", c2.i
        
        # The direction and distance from this craton to the edge of the next
        cr_dx = c2.x - c1.x
        cr_dy = c2.y - c1.y
        self.cr_d = math.sqrt(cr_dx * cr_dx + cr_dy * cr_dy) / 2.0

        print "cr =", cr_dx, cr_dy
        print "cr_d =", self.cr_d
        
        # Normalised direction vector
        self.cr_nx = cr_dx / self.cr_d / 2.0
        self.cr_ny = cr_dy / self.cr_d / 2.0
        print "cr_n =", self.cr_nx, self.cr_ny
        # The difference in craton movement
        m_dx = c2.driftx - c1.driftx
        m_dy = c2.drifty - c1.drifty
        print "m =", m_dx, m_dy
        
        # How much are the cratons drifting towards or away from each other?
        # Stress/strain
        ss = self.cr_nx * m_dx + self.cr_ny * m_dy
        print "ss =", ss

        # Peak height, maximum:
        print "Sides =", c1.height, c2.height
        lowerside = min(c1.height, c2.height)
        upperside = max(c1.height, c2.height)
        scaling = math.fabs(ss) / (2.0 * MAX_D)
        print "Scaling =", scaling
        
        if ss < 0 and math.fabs(c1.height - c2.height) < MOUNTAIN_THRESHOLD:
            print "Sides similar in height, moving together: mountain-building"
            spot = lowerside * scaling + upperside
        else:
            print "Sides moving apart, or much higher"
            if scaling < 0.5:
                spot = upperside - (upperside - lowerside) * (scaling + 0.5)
            else:
                spot = lowerside - (lowerside * 0.3 * (scaling - 0.5))

        print "Spot =", spot

        # Function params
        self.mult = spot - c1.height

        # We fall off at a half-distance of MOUNTAIN_HALF
        self.l = math.log(0.5) / MOUNTAIN_HALF

    def f(self, x):
        return self.mult * math.exp(self.l * (self.cr_d - x))

    def mountains(self, px, py):
        # How far are we in the direction between cratons?
        d = self.cr_nx * px + self.cr_ny * py

        # Return the extra height for this pair of cratons
        rv = self.f(d)
        return rv

class Loc(object):
    def __init__(self, x, y, c1, c2, d1, d2):
        self.x = x
        self.y = y
        if c1 != None:
            self.nearest = c1
            self.neighbour = c2
            self.nearest_d = math.sqrt(d1)
            self.neighbour_d = math.sqrt(d2)
            self.height = self.nearest.height # Initial height
            # Our position on this craton
            self.px = self.x - self.nearest.x
            self.py = self.y - self.nearest.y
        else:
            self.height = 0

        self.new_water = 0
        self.tot_water = 0

    def mountains(self):
        self.height += self.nearest.mountains(self.px, self.py)

    def distance_ratio(self):
        return self.nearest_d / self.neighbour_d

    def flow(self, *nbrs):
        downhill = self
        lowest = self.height
        for n in nbrs:
            if n.height < lowest:
                downhill = n
                lowest = n.height

        # FIXME

def to_scr(x, y):
    return ((MAX_X-MIN_X)+x*2+(y%2), (MAX_Y-MIN_Y)+y*2)

def calc_fnoise(fnoise, scale):
    ymx = 1 << scale
    for sc in range(scale-1, -1, -1):
        stride = 1 << sc
        xbit = True
        for x in range(0, 1 << scale + 1, stride):
            xbit = not xbit
            ybit = True
            maxy = (1 << scale) - x
            for y in range(0, maxy + 1, stride):
                ybit = not ybit
                if fnoise[x][y] != None:
                    continue
                tot = 0.0
                count = 0.0
                if xbit:
                    if ybit:
                        if y - stride >= 0 and (y-stride) + (x+stride) <= ymx:
                            count += 2
                            tot += 2* fnoise[x+stride][y-stride]
                        if x - stride >= 0 and (y+stride) + (x-stride) <= ymx:
                            count += 2
                            tot += 2* fnoise[x-stride][y+stride]
                        if x - stride >= 0 and y - stride >= 0:
                            count += 1
                            tot += fnoise[x-stride][y-stride]
                        if (y+stride) + (x+stride) <= ymx:
                            count += 1
                            tot += fnoise[x+stride][y+stride]
                    else:
                        if x - stride >= 0:
                            count += 2
                            tot += 2* fnoise[x-stride][y]
                        if y + (x+stride) <= ymx:
                            count += 2
                            tot += 2* fnoise[x+stride][y]
                        if ( (y+2*stride) + (x-stride) <= ymx
                             and x - stride >= 0):
                            count += 1
                            tot += fnoise[x-stride][y+2*stride]
                        if y - 2*stride >= 0:
                            count += 1
                            tot += fnoise[x+stride][y-2*stride]
                else:
                    if ybit:
                        if y - stride >= 0:
                            count += 2
                            tot += 2* fnoise[x][y-stride]
                        if y + stride <= maxy:
                            count += 2
                            tot += 2* fnoise[x][y+stride]
                        if x - 2*stride >= 0:
                            count += 1
                            tot += fnoise[x-2*stride][y+stride]
                        if ( (y-stride) + (x+2*stride) <= ymx
                            and y - stride >= 0):
                            count += 1
                            tot += fnoise[x+2*stride][y-stride]
                    else:
                        print "xbit and ybit are both false: WTF?"
    
                if count == 0.0:
                    print "Count is zero: WTF?", stride, x, y, xbit, ybit, maxx, maxy
    
                fnoise[x][y] = tot / count

                rrange = stride >> SMOOTHNESS * loc[x][y].nearest.cragginess

                fnoise[x][y] += randrange(-rrange, rrange+1)

def hydro(loc):
    # Start with a rain shower
    for x in range(MIN_X, MAX_X + 1):
        for y in range(MIN_Y, MAX_Y + 1):
            loc[x][y].water = 0.1

    # Model water flow
    for i in range(0, 100):
        sys.stdout.write(".")
        if i % 10 == 0:
            sys.stdout.write("/")
        sys.stdout.flush()
        hydro_flow(loc)

def hydro_flow(loc):
    for x in range(MIN_X, MAX_X + 1):
        for y in range(MIN_Y, MAX_Y + 1):
            loc[x][y].flow(loc[x-1][y],
                           loc[x+1][y],
                           loc[x-1+y%2][y+1],
                           loc[x+y%2][y+1],
                           loc[x-1+y%2][y-1],
                           loc[x+y%2][y-1])
    
    # Move across the new values
    for x in range(MIN_X, MAX_X + 1):
        for y in range(MIN_Y, MAX_Y + 1):
            loc[x][y].water = loc[x][y].new_water
            loc[x][y].tot_water += loc[x][y].water
            loc[x][y].new_water = 0
            
def plot(f):
    # Work out the dynamic range of the landscape
    min_h = 1e12
    max_h = -1e12
    for x in range(MIN_X, MAX_X+1):
        for y in range(MIN_Y, MAX_Y+1):
            if loc[x][y].height != None:
                min_h = min(min_h, loc[x][y].height)
                max_h = max(max_h, loc[x][y].height)

    print "Height range:", min_h, "to", max_h

    # Draw the output
    pygame.init()
    screen = pygame.display.set_mode(((MAX_X-MIN_X+1)*2, (MAX_Y-MIN_Y+1)*2))
    screen.fill((0,0,0))

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()

        for x in range(MIN_X, MAX_X+1):
            for y in range(MIN_Y, MAX_Y+1):
                if loc[x][y].height == None:
                    colh = 0
                else:
                    colh = float(loc[x][y].height-min_h)/float(max_h-min_h+1) * 255

                if colh > 255 or colh < 0:
                    col = (0, 255, 0)
                else:
                    col = (colh, colh, colh)
                
                pygame.draw.rect(screen,
                                 col,
                                 pygame.Rect(to_scr(x, y), (2, 2)))

        for c in cratons:
            pygame.draw.circle(screen,
                               (0, 0, 0),
                               to_scr(c.x, c.y),
                               3)
            pygame.draw.line(screen,
                             (0, 0, 0),
                             to_scr(c.x, c.y),
                             to_scr(c.x + c.driftx, c.y + c.drifty)
                             )
            for n in c.neighbours:
                pygame.draw.line(screen,
                                 (255, 0, 0),
                                 to_scr(c.x, c.y),
                                 to_scr(n.x, n.y)
                                 )

###############################################################

# Generate a set of cratons
for i in range(0, NCRATONS):
    cratons.append(Craton(i))

#cratons.append(Craton(0, -50, 0, 30, 10, 1))
#cratons.append(Craton(1, 50, 0, 50, -10, 1))
#cratons.append(Craton(2, 0, 75, 70, -10, 1))

# Generate for each point in the output space the nearest and
# next-nearest craton centre
loc = [ [ 0 for y in range(MIN_Y, MAX_Y+1) ] for x in range(MIN_X, MAX_X+1) ]
for x in range(MIN_X, MAX_X+1):
    for y in range(MIN_Y, MAX_Y+1): 
        d = 1e8
        d2 = 1e8
        cton = None
        cton2 = None
#        for c in cratons:
#            dist = c.d2(x, y)
#            if dist < d:
#                d2 = d
#                d = dist
#                cton2 = cton
#                cton = c
#            elif dist < d2:
#                d2 = dist
#                cton2 = c
#
        loc[x][y] = Loc(x, y, cton, cton2, d, d2)
#        cton.add_nbr(cton2)
#        cton2.add_nbr(cton)

# Average out the cratons
#for c in cratons:
#    c.average()

# Set up a triangle
# Scale large enough to fit the square in it
scale = int(math.ceil(math.log((MAX_X-MIN_X+1) * (1+2/math.sqrt(3))) / math.log(2) ))
print "Triangle scale =", scale
fnoise = [ [ None for y in range(0, (1 << scale) + 1 - x) ] for x in range(0, (1 << scale) + 1) ]
# Work out the best relative offsets of the zero point in square and triangle
# Centred horizontally
diff_x = MIN_X + int(math.ceil(MIN_X * 2 / math.sqrt(3)))
diff_y = MIN_Y

# A function to map square coords into triangle ones
s_to_t = lambda x, y: (x - int(math.floor((y - diff_y)/2)) - diff_x, y - diff_y)
# And its inverse
t_to_s = lambda x, y: (x + int(math.floor((y + diff_y)/2)) + diff_x, y + diff_y)

# Just check sanity
ok = 0
(tx, ty) = s_to_t(MIN_X, MIN_Y)
if ty >= 0 and tx >= 0 and ty+tx < (1 << scale + 1):
    print "SW point in triangle"
    ok += 1
(tx, ty) = s_to_t(MIN_X, MAX_Y)
if ty >= 0 and tx >= 0 and ty+tx < (1 << scale + 1):
    print "NW point in triangle"
    ok += 1
(tx, ty) = s_to_t(MAX_X, MIN_Y)
if ty >= 0 and tx >= 0 and ty+tx < (1 << scale + 1):
    print "SE point in triangle"
    ok += 1
(tx, ty) = s_to_t(MAX_X, MAX_Y)
if ty >= 0 and tx >= 0 and ty+tx < (1 << scale + 1):
    print "NE point in triangle"
    ok += 1
if ok < 4:
    print "FAIL"
    sys.exit(1)

# Now, for each point in a grid of given size, near a craton edge,
# there's a small chance of it having a height set
#for tx in range(0, (1 << scale) + 1, 1 << SEED_SCALE):
#    for ty in range(0, (1 << scale) + 1 - tx, 1 << SEED_SCALE):
#        (sx, sy) = t_to_s(tx, ty)
#        if sx < MIN_X or sx >= MAX_X or sy < MIN_Y or sy >= MAX_Y:
#            continue
#        if loc[sx][sy].distance_ratio() > 0.85:
#            if random() < 0.2:
#                # Set a point in the triangle
#                fnoise[tx][ty] = loc[sx][sy].height # This should be a more complex height calculation
#        else:
#            if random() < 0.1:
#                fnoise[tx][ty] = loc[sx][sy].height

# Set the corners
fnoise[0][0] = randrange(MIN_H, MAX_H)
fnoise[1 << scale][0] = randrange(MIN_H, MAX_H)
fnoise[0][1 << scale] = randrange(MIN_H, MAX_H)

# Compute the fractal noise function
calc_fnoise(fnoise, scale)

# Transfer the triangle back to the square
for sx in range(MIN_X, MAX_X+1):
    for sy in range(MIN_Y, MAX_Y+1):
        (tx, ty) = s_to_t(sx, sy)
        loc[sx][sy].height = fnoise[tx][ty]

# Do some modelling of hydrology
hydro(loc)

# Plot the landscape
#plot(lambda x, y: loc[x][y].height)
plot(lambda x, y: loc[x][y].tot_water)
