#!/usr/bin/python

import pygame
import sys
import math

from random import randrange, random
from colorsys import hsv_to_rgb

NCRATONS=40
MARGIN=12.

MIN_X=-150
MIN_Y=-150
MIN_H=0
MAX_X=150
MAX_Y=150
MAX_H=500

MAX_D=20

MOUNTAIN_THRESHOLD = 40
MOUNTAIN_HALF = 50

cratons = []

class Craton(object):
    def __init__(self, i,
                 x = None,
                 y = None,
                 height = None,
                 driftx = None,
                 drifty = None):
        if x == None: x = randrange(MIN_X, MAX_X+1)
        if y == None: y = randrange(MIN_Y, MAX_Y+1)
        if height == None: height = randrange(0, 150)
        
        self.i = i
        self.x = x
        self.y = y
        self.height = height
        
        if driftx == None or drifty == None:
            r = randrange(0, MAX_D)+1
            t = math.radians(randrange(0, 360))
            self.driftx = r * math.cos(t)
            self.drifty = r * math.sin(t)
        else:
            self.driftx = driftx
            self.drifty = drifty
        self.colour = hsv_to_rgb(i/float(NCRATONS), 1.0, 1.0)
        self.colour = [ j*255 for j in self.colour ]
        self.neighbours = set()
        self.relations = set()

    def d2(self, x, y):
        dx = self.x - x
        dy = self.y - y
        return dx*dx + dy*dy

    def add_nbr(self, c):
        if c not in self.neighbours:
            self.neighbours.add(c)
            self.relations.add(CratonRelation(self, c))

    def average(self):
        tot = 2 * self.height
        for c in self.neighbours:
            tot += c.height
        self.height = tot / (len(self.neighbours) + 2)

    def mountains(self, x, y):
        tot = 0
        for rel in self.relations:
            tot += rel.mountains(x, y)

        return tot

class CratonRelation(object):
    def __init__(self, c1, c2):
        self.c1 = c1
        self.c2 = c2

        print "From", c1.i, "to", c2.i
        
        # The direction and distance from this craton to the edge of the next
        cr_dx = c2.x - c1.x
        cr_dy = c2.y - c1.y
        self.cr_d = math.sqrt(cr_dx * cr_dx + cr_dy * cr_dy) / 2.0

        print "cr =", cr_dx, cr_dy
        print "cr_d =", self.cr_d
        
        # Normalised direction vector
        self.cr_nx = cr_dx / self.cr_d / 2.0
        self.cr_ny = cr_dy / self.cr_d / 2.0
        print "cr_n =", self.cr_nx, self.cr_ny
        # The difference in craton movement
        m_dx = c2.driftx - c1.driftx
        m_dy = c2.drifty - c1.drifty
        print "m =", m_dx, m_dy
        
        # How much are the cratons drifting towards or away from each other?
        # Stress/strain
        ss = self.cr_nx * m_dx + self.cr_ny * m_dy
        print "ss =", ss

        # Peak height, maximum:
        print "Sides =", c1.height, c2.height
        lowerside = min(c1.height, c2.height)
        upperside = max(c1.height, c2.height)
        scaling = math.fabs(ss) / (2.0 * MAX_D)
        print "Scaling =", scaling
        
        if ss < 0 and math.fabs(c1.height - c2.height) < MOUNTAIN_THRESHOLD:
            print "Sides similar in height, moving together: mountain-building"
            spot = lowerside * scaling + upperside
        else:
            print "Sides moving apart, or much higher"
            if scaling < 0.5:
                spot = upperside - (upperside - lowerside) * (scaling + 0.5)
            else:
                spot = lowerside - (lowerside * 0.3 * (scaling - 0.5))

        print "Spot =", spot

        # Function params
        self.mult = spot - c1.height

        # We fall off at a half-distance of MOUNTAIN_HALF
        self.l = math.log(0.5) / MOUNTAIN_HALF

    def f(self, x):
        return self.mult * math.exp(self.l * (self.cr_d - x))

    def mountains(self, px, py):
        # How far are we in the direction between cratons?
        d = self.cr_nx * px + self.cr_ny * py

        # Return the extra height for this pair of cratons
        rv = self.f(d)
        return rv

class Loc(object):
    def __init__(self, x, y, c1, c2, d1, d2):
        self.x = x
        self.y = y
        self.nearest = c1
        self.neighbour = c2
        self.nearest_d = math.sqrt(d1)
        self.neighbour_d = math.sqrt(d2)
        self.height = self.nearest.height # Initial height
        # Our position on this craton
        self.px = self.x - self.nearest.x
        self.py = self.y - self.nearest.y

    def mountains(self):
        self.height += self.nearest.mountains(self.px, self.py)

    def distance_ratio(self):
        return self.nearest_d / self.neighbour_d

def to_scr(x, y):
    return ((MAX_X-MIN_X)+x*2+(y%2), (MAX_Y-MIN_Y)+y*2)

# Generate a set of cratons
for i in range(0, NCRATONS):
    cratons.append(Craton(i))

#cratons.append(Craton(0, -50, 0, 30, 10, 1))
#cratons.append(Craton(1, 50, 0, 50, -10, 1))
#cratons.append(Craton(2, 0, 75, 70, -10, 1))

# Generate for each point in the output space the nearest and
# next-nearest craton centre
loc = [ [ 0 for y in range(MIN_Y, MAX_Y+1) ] for x in range(MIN_X, MAX_X+1) ]
for x in range(MIN_X, MAX_X+1):
    for y in range(MIN_Y, MAX_Y+1): 
        d = 1e8
        d2 = 1e8
        cton = None
        cton2 = None
        for c in cratons:
            dist = c.d2(x, y)
            if dist < d:
                d2 = d
                d = dist
                cton2 = cton
                cton = c
            elif dist < d2:
                d2 = dist
                cton2 = c

        loc[x][y] = Loc(x, y, cton, cton2, d, d2)
        cton.add_nbr(cton2)
        cton2.add_nbr(cton)

# Average out the cratons
#for c in cratons:
#    c.average()

# Set up a triangle
# Scale large enough to fit the square in it
scale = int(math.ceil(math.log((MAX_X-MIN_X+1) * (1+2/math.sqrt(3))) / math.log(2) ))
print "Triangle scale =", scale
fnoise = [ [ None for y in range(0, (1 << scale) + 1 - x) ] for x in range(0, (1 << scale) + 1) ]
# Work out the best relative offsets of the zero point in square and triangle
# Centred horizontally
diff_x = MIN_X + int(math.ceil(MIN_X * 2 / math.sqrt(3)))
diff_y = MIN_Y

# A function to map square coords into triangle ones
s_to_t = lambda x, y: (x - int(math.floor((y - diff_y)/2)) - diff_x, y - diff_y)
# And its inverse
t_to_s = lambda x, y: (x + int(math.floor((y + diff_y)/2)) + diff_x, y + diff_y)

# Just check sanity
ok = 0
(tx, ty) = s_to_t(MIN_X, MIN_Y)
if ty >= 0 and tx >= 0 and ty-tx < (1 << scale + 1):
    print "SW point in triangle"
    ok += 1
(tx, ty) = s_to_t(MIN_X, MAX_Y)
if ty >= 0 and tx >= 0 and ty-tx < (1 << scale + 1):
    print "NW point in triangle"
    ok += 1
(tx, ty) = s_to_t(MAX_X, MIN_Y)
if ty >= 0 and tx >= 0 and ty-tx < (1 << scale + 1):
    print "SE point in triangle"
    ok += 1
(tx, ty) = s_to_t(MAX_X, MAX_Y)
if ty >= 0 and tx >= 0 and ty-tx < (1 << scale + 1):
    print "NE point in triangle"
    ok += 1
if ok < 4:
    print "FAIL"
    sys.exit(1)

# Now, for each point near a craton edge, there's a small chance of it having a
# height set
for sx in range(MIN_X, MAX_X+1):
    for sy in range(MIN_Y, MAX_Y+1):
        if loc[sx][sy].distance_ratio() > 0.85:
            if random() < 0.005: # One part in 200
                # Set a point in the triangle
                (tx, ty) = s_to_t(sx, sy)
                fnoise[tx][ty] = loc[sx][sy].height # This should be a more complex height calculation
        else:
            if random() < 0.001: # One part in 1000
                (tx, ty) = s_to_t(sx, sy)
                fnoise[tx][ty] = loc[sx][sy].height

# Set the corners
fnoise[0][0] = randrange(MIN_H, MAX_H)
fnoise[1 << scale][0] = randrange(MIN_H, MAX_H)
fnoise[0][1 << scale] = randrange(MIN_H, MAX_H)

# Compute the fractal noise function
for sc in range(scale-1, -1, -1):
    stride = 1 << sc
    for x in range(0, 1 << scale + 1, stride):
        for y in range(0, (1 << scale) - x + 1, stride):
            tot = fnoise[x][y]
            count = 1
            # FIXME
            

# Transfer the triangle back to the square
for sx in range(MIN_X, MAX_X+1):
    for sy in range(MIN_Y, MAX_Y+1):
        (tx, ty) = s_to_t(sx, sy)
        loc[sx][sy].height = fnoise[tx][ty]

# Work out the dynamic range of the landscape
min_h = 1e6
max_h = -1e6
for x in range(MIN_X, MAX_X+1):
    for y in range(MIN_Y, MAX_Y+1):
        if loc[x][y].height != None:
            min_h = min(min_h, loc[x][y].height)
            max_h = max(max_h, loc[x][y].height)

print "Height range:", min_h, "to", max_h

# Draw the output
pygame.init()
screen = pygame.display.set_mode(((MAX_X-MIN_X+1)*2, (MAX_Y-MIN_Y+1)*2))
screen.fill((0,0,0))

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

    for x in range(MIN_X, MAX_X+1):
        for y in range(MIN_Y, MAX_Y+1):
            if loc[x][y].height == None:
                colh = 0
            else:
                colh = float(loc[x][y].height-min_h)/float(max_h-min_h+1) * 255
            if colh > 255 or colh < 0:
                col = (0, 255, 0)
            else:
                col = (colh, colh, colh)
                
            pygame.draw.rect(screen,
                             col,
                             pygame.Rect(to_scr(x, y), (2, 2)))

    for c in cratons:
        pygame.draw.circle(screen,
                           (0, 0, 0),
                           to_scr(c.x, c.y),
                           3)
        pygame.draw.line(screen,
                         (0, 0, 0),
                         to_scr(c.x, c.y),
                         to_scr(c.x + c.driftx, c.y + c.drifty)
                         )
        for n in c.neighbours:
            pygame.draw.line(screen,
                             (255, 0, 0),
                             to_scr(c.x, c.y),
                             to_scr(n.x, n.y)
                             )
                        
